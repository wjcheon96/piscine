# Shell01

### ex01

---

환경 변수 FT_USER에 포함된 login이 소속된 그룹의 목록을 표시하는 명령어를 작성하는 문제.

이때, login이 소속된 그룹의 목록은 사용자 ID를 나타내며, 환경변수의 설정 및 이를 옵션에 따라 표시되게끔 해야한다.

먼저, 환경변수의 설정은 다음과 같다.

```export [환경변수명]=[값]```

이렇게 설정한 환경변수를 확인하는 방법은 다음과 같다.

```env | grep [환경변수명]```

따라서, 문제에서 요구하는 명령어는 다음과 같다.

```id -Gn $FT_USER | sed 's/ /\,/g' | tr -d '\n'```

해당 id 그룹의 목록을 나타내기에 -G와 n 옵션을, FT_USER안에 포함된 환경변수만 표시하기에 $FT_USER를 붙여준다.
쉘에서 파이프라인(|)은 각각의 프로세스를 명령어를 실행한 터미널 프로세스의 자식 프로세스로 백그라운드에서 시작한다.

이후, sed 명령어를 통해 공백( )을 ,로 치환시키고, tr 명령어를 통해 개행을 지워준다.
이때, sed는 문자열 단위 치환이라 개행 문자를 지울 수는 있으나 개행을 하는 행위 자체를 지울 수 없기에
바이트 단위 치환 및 삭제 기능을 가진 tr 명령어를 통해 지워준다.

### ex02

---

현재 디렉토리와 그 화위 디렉토리에서 파일 이름이 .sh로 끝나는 파일을 찾는 문제.
이때, .sh를 제외한 파일 이름만 표시해야한다.

해당 파일의 명령어는 다음과 같다.

```find . -name  "*.sh" -exec basename {} .sh \;```

.sh로 끝나는 모든 파일의 이름을 찾고, -exec를 통해 해당 명령어를 실행하는데 새로운 프로세스를 생성하지 않고, 쉘 프로세스로 대체하게끔 한다.
exec는 간단한 쉘 함수로, 조건을 가지고 찾은 파일을 대상으로 해당 명령어를 실행하라는 의미를 지닌다.
이때, 해당 명령어는 ;(세미콜론)을 만나기 전 까지를 의미하며, basename 명령어를 통해, 파일 명만 추출 할 수있다.

```basename [파일명] [확장자]```

와 같은 형태로 쓰이며, 찾은 모든 파일의 파일명에서 확장자를 제거한다는 의미를 지닌다.

### ex03

---

현재 디렉토리 및 그 하위 디렉토리에 있는 일반 파일 및 디렉토리의 개수를 세서 표시하는 명령어의 작성

해당 명령어는 다음과 같다.

```find . \(-type d o -type f \) | wc -l | tr -d " "```

d(디렉토리), f(파일) 타입으로 된 모든 파일을 현재 디렉토리부터 하부 디렉토리까지 find 명령어를 통해 찾아서,
해당 부분까지만 명령어 처리시 모든 파일명들이 한 줄 단위로 나오게 되어있다.
이를 wc -l 명령어를 통해 갯수를 세 주는데, -l 명령어로 line 즉, 줄 갯수를 셈으로서 갯수를 세준다.
이렇게만 처리할 시 공백 구간이 많이 나오게 되어, 이를 제거하기위해 tr -d 옵션을 통한 명령어로 공백들을 다 지워준다.

### ex04

---

MAC 주소란 데이터 통신에서 쓰이는 프로토콜의 계층으로, 네트워크 통신을 계층화해 설명하는 OSI 모델에서 데이터 링크 계층의 일부에 해당한다.

간단하게 말해서, 인터넷을 할 수 있는 이더넷 기반 기기에 모두 하나씩 할당되어있는 고유한 ID이다.
총 48비트로 구성되어있으며, 편의상 8비트씩 6자리로 구분해 표시한다.
앞의 세자리(24비트)는 제조사 코드, 뒤의 세자리(23비트)는 기기 고유 코드를 나타낸다.

해당 명령어는 다음과 같다.

```ifconfig | grep -w 'ether' | awk '{ print $2}'```

ifconfig 명령어를 통해서 mac주소를 찾을 수 있는데, 이 중 ether라는 단어를 포함한 부분이 MAC 주소를 나타내기에,
grep -w 명령어를 통해서 그 부분만 추출해낸다. 이후, awk 명령어를 통해 필드를 출력시키는게 가능한데, 필드란 간단하게 행렬의 열을 나타낸다 보면 된다.
awk '{ print $2}'는 2번 필드를 출력하겠다는 뜻으로, 1번 필드는 ether가 들어가있는 부분이며, 그 부분이 아닌 부분이 MAC주소이기에 2번필드를 출력시킨다.

### ex05

---

"\?$*'MaRViN'*$?\" 

위와 같은 이름을 지닌 파일을 만드는데, 그 안에 들어가있는 내용은 42만 들어가있어야 한다.
해당 파일을 만드는데 있어, (" \ ? $ ') 이 5개의 문자는 특수문자로, 쉘에서는 이를 특수문자로 인식하지 않기에
앞에 \(역슬래쉬)를 붙여 특수문자로 인식하게끔 해준다.

이후 파일을 만드는데 있어 안에 들어가 있는 내용은 42 라는 2바이트 숫자만 들어가있어야하는데, vim editor를 통해 파일을 만들어서 42를 집어넣게 되면
자동으로 개행문자를 입력시켜 총 3바이트가 들어가게 된다.

따라서 42를 제외한 개행문자를 제거하는 방법은 여러가지가 있으나, 내가 사용한 방법은 다음과 같다.

```cat > [파일명]```
으로 파일을 생성시 그 파일 안에 데이터를 입력하는게 가능한데, 이때 42를 집어넣고 ```ctrl + c``` 키를 누르면 강제저장이 가능하다.
이를 통해 개행없이 42만 들어가있는 파일의 생성이 가능하다.

### ex06

---

ls -l 명령어를 실행시키되, 홀수 행만 출력하게끔 하는 명령어를 작성하라는 문제.

명령어는 다음과 같다.

```ls -l | awk 'NR%2==1```

위에서 본 awk명령어를 다시 써주는데, 이때는 NR을 사용한다. NR은 각 레코드들의 번호를 빌트인 변수 NR에서 저장시킨 것으로,
레코드는 행 으로 보면 된다.

행 번호, 즉 몇번째 줄인지 나타내는 숫자를 2로 나눴을때 나머지가 1인 경우가 홀수 행이기에, 그 부분만 추출한다는 뜻이다.

### ex07

---

cat /etc/passwd 명령어를 실행시키되, 주석삭제, 두번째 행부터 모든 행을 출력시키는데 login id를 거꾸로 반전시키고,
역순 정렬 후 FT_LINE1 과 FT_LINE2의 환경변수값 사이에 있는 값만 남기며, 각 login은 ,(콤마)로 구분하고, 출력결과의 마지막엔 .(온점)으로 끝내야 한다.

해당 명령어는 다음과 같다.

```cat /etc/passwd | grep -v "^#" | awk "NR % 2 == 0" | cut -d ":" -f 1 | rev | sort -r | sed -n ''$FT_LINE1','$FT_LINE2'p' | tr '\n' ' ' | sed 's/ /, /g' | sed 's/, $/./' | tr -d '\n' ```

grep -v 명령어를 통해 주석을 나타내는 ^# 부분을 전부 제외시키고, awk "NR % 2 == 0" 명령어를 통해서 ex06번과는 반대로 짝수 행을 출력시킨다.
login id 값을 반전시켜 출력시키기 위해 먼저 로그인 부분만 남겨야 하는데, 이를 cut -d 명령어를 통해 :(세미콜론)을 구분자로 해 id값을 나타내는 첫번째 필드만 추출한다.
이후 rev 명령어를 통해 반전, sed -n ''$FT_LINE1','$FT_LINE2'p'명령어를 통해 저 두 환경변수 사이에 있는 값만을 추출한다.
개행을 없애기 위해 tr 명령어를 통해 공백으로 바꿔주고, 그렇게 바꾼 공백을 (, )으로 치환, 마지막 부분은 개행 문자가 들어가있기에 마지막만 .으로 치환시킨다.

개행문자를 지웠음에도 다시 개행문자가 나타나는 이유는, 파이프라인을 넘어가면서 명령이 실행되기에 마지막에 개행문자가 남게되는 것이며, 이를 통해 출력결과의 끝임을 알 수 있다.
이렇게 바꾼 이후 생긴 개행문자를 tr 명령어를 통해 다시 지워준다.

### ex08

---

'\"?!의 5가지 숫자를 밑으로 하는, 즉 저 5개의 문자로 이루어진 5진법 숫자와 mrdoc를 밑으로 하는 5진법 숫자를 각각의 환경변수 FT_NBR1과 FT_NBR2에서 가져와,
두 수를 합하고 gtaio luSnemf로 이루어진 13진수 숫자로의 변환을 시키는 문제이다.

명령어는 다음과 같다.

```echo $FT_NBR1 + $FT_NBR2 | sed "s/\'/0/g" | tr '\\\"\?\!' 1234 | tr 'mrdoc' 01234 | xargs echo 'obase=13; ibase=5;' | bc | tr 0123456789ABC 'gtaio luSnemf'```

export 명령어를 통해 환경변수 설정을 해준 이후, 
echo 명령어를 통해, $FT_NBR1 + $FT_NBR2 라는 문자열을 출력시키는것을 통해 결과값을 가져갈 것이다.

앞의 echo 명령어 부분만 실행시키면, ```'\"?! + mrdoc```라는 환경변수의 값과 + 기호를 단순 출력시킨 것만 나온다.
이후 sed 명령어와 tr 명령어를 통해 '\"?!를 01234를 밑으로 지닌 숫자로 변경 시키고, mrdoc 또한 같은 과정을 거친다.
이때 sed와 tr 명령어를 통해 FT_NBR1을 분리해서 치환하는 이유는 '(작은 따옴표) 기호와 "(큰 따옴표) 기호 두개를 모두 사용하기에 오류가 나지 않게 하기 위해 위와 같이 처리해준다.

이후, xargs 명령어를 통해 앞 명령어의 출력 결과를 다음 명령어의 인자로 사용하게끔 해준다.
즉, 앞의 명령을 통해 5진법 숫자 두개를 + 기호로 연결시킨 값을, 5진법에서 13진법으로 더할수 있게끔 명령어의 인자로 변경시켜준다.

bc 명령어를 통해 해당 인자를 수식으로 인식시켜 계산을 하면, 통상적으로 아는 13진법 숫자가 나오며, 출력 결과값은 gtaio luSnemf가 밑은 숫자로 나와야 하기에,
tr 명령어를 통해 13진법을 변환 시켜주면 된다.
